module tosig
integer,parameter :: d=3
!integer,parameter :: ord=6
integer,parameter :: ord=4
integer, parameter:: dim = (d**(ord+1)-1)/(d-1)
contains  
subroutine variance(M,V)
implicit none
integer:: i, j
real(kind=8), intent(in):: M(dim)
real(kind=8), intent(inout):: V(dim,dim)
do j = 1,dim
   do i = 1,dim
      V(i,j) = V(i,j) + M(i)*M(j)
   enddo
enddo
end subroutine variance
!subroutine tensor2vec(X1,X2,X3,X4,X5,X6,A)
subroutine tensor2vec(X1,X2,X3,X4,A)
implicit none
integer:: n, k, k0, k1
real(kind=8), intent(out) :: A(dim)
real(kind=8), intent(in)  :: X1(d)
real(kind=8), intent(in)  :: X2(d,d)
real(kind=8), intent(in)  :: X3(d,d,d)
real(kind=8), intent(in)  :: X4(d,d,d,d)
!real(kind=8), intent(in)  :: X5(d,d,d,d,d)
!real(kind=8), intent(in)  :: X6(d,d,d,d,d,d)
real(kind=8) :: X1d(d)
real(kind=8) :: X2d(d,d)
real(kind=8) :: X3d(d,d,d)
real(kind=8) :: X4d(d,d,d,d)
!real(kind=8) :: X5d(d,d,d,d,d)
!real(kind=8) :: X6d(d,d,d,d,d,d)
!A = 0.0
!Fortran order to C order
X1d=reshape(X1,(/d/),order=(/1/))
X2d=reshape(X2,(/d,d/),order=(/2, 1/))
X3d=reshape(X3,(/d,d,d/),order=(/3, 2, 1/))
X4d=reshape(X4,(/d,d,d,d/),order=(/4, 3, 2, 1/))
!X5d=reshape(X5,(d,d,d,d,d/),order=(/5, 4, 3, 2, 1/))
!X6d=reshape(X6,(d,d,d,d,d,d/),order=(/6, 5, 4, 3, 2, 1/))
!flatten
k1=1
A(k1) = 1.0
k=1; k0 = k1 + 1; k1 = k1 + d**k
A(k0:k1) = reshape(X1d,(/ d**k /))
k=2; k0 = k1 + 1; k1 = k1 + d**k
A(k0:k1) = reshape(X2d,(/ d**k /))
k=3; k0 = k1 + 1; k1 = k1 + d**k
A(k0:k1) = reshape(X3d,(/ d**k /))
k=4; k0 = k1 + 1; k1 = k1 + d**k
A(k0:k1) = reshape(X4d,(/ d**k /))
!k=5; k0 = k1 + 1; k1 = k1 + d**k
!A(k0:k1) = reshape(X5d,(/ d**k /))
!k=6; k0 = k1 + 1; k1 = k1 + d**k
!A(k0:k1) = reshape(X6d,(/ d**k /))
end subroutine tensor2vec
subroutine p2s( X, Sig1, n)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: n
real(kind=8), intent(in) :: X(d,n)
real(kind=8), intent(out):: Sig1(dim)

!==============================================
! declare local variables
!==============================================
real(kind=8) :: X1(d)
real(kind=8) :: X2(d,d)
real(kind=8) :: X3(d,d,d)
real(kind=8) :: X4(d,d,d,d)
!real(kind=8) :: X5(d,d,d,d,d)
!real(kind=8) :: X6(d,d,d,d,d,d)
real(kind=8) :: DX(d,n-1)
real(kind=8) :: Y1(d)
real(kind=8) :: Y2(d,d)
real(kind=8) :: Y3(d,d,d)
real(kind=8) :: Y4(d,d,d,d)
!real(kind=8) :: Y5(d,d,d,d,d)
!real(kind=8) :: Y6(d,d,d,d,d,d)
integer :: j

call delta_s( X,DX,n )
X1 = 0.0d0
X2 = 0.0d0
X3 = 0.0d0
X4 = 0.0d0
!X5 = 0.0d0
!X6 = 0.0d0
do j = 1, n-1
!  call seg( DX(:,j),Y1,Y2,Y3,Y4,Y5,Y6 )
  call seg( DX(:,j),Y1,Y2,Y3,Y4 )
!  call conc( X1,X2,X3,X4,X5,X6,Y1,Y2,Y3,Y4,Y5,Y6 )
  call conc( X1,X2,X3,X4,Y1,Y2,Y3,Y4 )
end do
!call tensor2vec(X1, X2, X3, X4, X5, X6, Sig1)
call tensor2vec(X1, X2, X3, X4, Sig1)
end subroutine p2s
!subroutine seg( X, X1, X2, X3, X4, X5, X6)
subroutine seg( X, X1, X2, X3, X4)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=8), intent(in) :: X(d)
real(kind=8), intent(out) :: X1(d)
real(kind=8), intent(out) :: X2(d,d)
real(kind=8), intent(out) :: X3(d,d,d)
real(kind=8), intent(out) :: X4(d,d,d,d)
!real(kind=8), intent(out) :: X5(d,d,d,d,d)
!real(kind=8), intent(out) :: X6(d,d,d,d,d,d)

!==============================================
! declare local variables
!==============================================
integer :: i1
integer :: i2
integer :: i3
integer :: i4
!integer :: i5
!integer :: i6

do i1 = 1, d
  X1(i1) = X(i1)
  do i2 = 1, d
    X2(i1,i2) = X(i1)*X(i2)/2.
    do i3 = 1, d
      X3(i1,i2,i3) = X(i1)*X(i2)*X(i3)/6.
      do i4 = 1, d
        X4(i1,i2,i3,i4) = X(i1)*X(i2)*X(i3)*X(i4)/24.
!        do i5 = 1, d
!          X5(i1,i2,i3,i4,i5) = X(i1)*X(i2)*X(i3)*X(i4)*X(i5)/120.
!          do i6 = 1, d
!            X6(i1,i2,i3,i4,i5,i6) = X(i1)*X(i2)*X(i3)*X(i4)*X(i5)*X(i6)/720.
!          end do
!        end do
      end do
    end do
  end do
end do
end subroutine seg
!subroutine conc( X1, X2, X3, X4, X5, X6, Y1, Y2, Y3, Y4, Y5, Y6)
subroutine conc( X1, X2, X3, X4, Y1, Y2, Y3, Y4)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=8), intent(inout) :: X1(d)
real(kind=8), intent(inout) :: X2(d,d)
real(kind=8), intent(inout) :: X3(d,d,d)
real(kind=8), intent(inout) :: X4(d,d,d,d)
!real(kind=8), intent(inout) :: X5(d,d,d,d,d)
!real(kind=8), intent(inout) :: X6(d,d,d,d,d,d)
real(kind=8), intent(in) :: Y1(d)
real(kind=8), intent(in) :: Y2(d,d)
real(kind=8), intent(in) :: Y3(d,d,d)
real(kind=8), intent(in) :: Y4(d,d,d,d)
!real(kind=8), intent(in) :: Y5(d,d,d,d,d)
!real(kind=8), intent(in) :: Y6(d,d,d,d,d,d)

!==============================================
! declare local variables
!==============================================
real(kind=8) :: Z1(d)
real(kind=8) :: Z2(d,d)
real(kind=8) :: Z3(d,d,d)
real(kind=8) :: Z4(d,d,d,d)
!real(kind=8) :: Z5(d,d,d,d,d)
!real(kind=8) :: Z6(d,d,d,d,d,d)
integer :: i1
integer :: i2
integer :: i3
integer :: i4
!integer :: i5
!integer :: i6

do i1 = 1, d
  Z1(i1) = X1(i1)+Y1(i1)
  do i2 = 1, d
    Z2(i1,i2) = X2(i1,i2)+X1(i1)*Y1(i2)+Y2(i1,i2)
    do i3 = 1, d
       Z3(i1,i2,i3) = X3(i1,i2,i3)+X2(i1,i2)*Y1(i3) &
       +X1(i1)*Y2(i2,i3)+Y3(i1,i2,i3)
      do i4 = 1, d
         Z4(i1,i2,i3,i4) = X4(i1,i2,i3,i4)+X3(i1,i2,i3)*Y1(i4)&
         +X2(i1,i2)*Y2(i3,i4)+X1(i1)*Y3(i2,i3,i4)+Y4(i1,i2,i3,i4)
        ! do i5 = 1, d
        !    Z5(i1,i2,i3,i4,i5) = X5(i1,i2,i3,i4,i5)&
        !         +X4(i1,i2,i3,i4)*Y1(i5)+X3(i1,i2,i3)*Y2(i4,i5)&
        !         +X2(i1,i2)*Y3(i3,i4,i5)+X1(i1)*Y4(i2,i3,i4,i5)&
        !         +Y5(i1,i2,i3,i4,i5)
        !   do i6 = 1, d
        !      Z6(i1,i2,i3,i4,i5,i6) = X6(i1,i2,i3,i4,i5,i6)&
        !           +X5(i1,i2,i3,i4,i5)*Y1(i6)+X4(i1,i2,i3,i4)*Y2(i5,i6)&
        !           +X3(i1,i2,i3)*Y3(i4,i5,i6)+X2(i1,i2)*Y4(i3,i4,i5,i6)&
        !           +X1(i1)*Y5(i2,i3,i4,i5,i6)+Y6(i1,i2,i3,i4,i5,i6)
        !   end do
        ! end do
      end do
    end do
  end do
end do
X1 = Z1
X2 = Z2
X3 = Z3
X4 = Z4
!X5 = Z5
!X6 = Z6
end subroutine conc
subroutine delta_s( X, DX,n)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: n
real(kind=8), intent(out) :: DX(d,n-1)
real(kind=8), intent(in) :: X(d,n)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: j

do i = 1, d
  do j = 1, n-1
    DX(i,j) = X(i,j+1)-X(i,j)
  end do
end do
end subroutine delta_s
end module tosig
